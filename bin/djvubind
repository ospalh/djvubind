#! /usr/bin/env python3

#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc.

import optparse
import os
import queue
import shutil
import sys
import tempfile
import threading
import time

# Check if we are working in the source tree or from an installed package
# When in the source tree, adjust the python path accordingly for importation of
# djvubind modules from source.
loc = os.path.realpath(__file__)
loc = os.path.dirname(loc)
loc = os.path.join(loc+'/', '../djvubind')
loc = os.path.normpath(loc)
if os.path.isdir(loc):
    sys.path.insert(0, os.path.dirname(loc))

import djvubind.encode
import djvubind.ocr
import djvubind.organizer
import djvubind.utils


class ThreadAnalyze(threading.Thread):
    def __init__(self, q):
        threading.Thread.__init__(self)
        self.queue = q

        self.quit = False

    def run(self):
        while not self.quit:
            try:
                # Process the page
                page = self.queue.get()
                page.is_bitonal()
                page.get_dpi()
            except queue.Empty:
                self.quit = True
            except:
                msg = 'wrn: Analysis failure on {0}.'.format(os.path.split(page.path)[1])
                msg = djvubind.utils.color(msg, 'red')
                print(msg, file=sys.stderr)
                sys.exit(1)
            finally:
                self.queue.task_done()

class ThreadOCR(threading.Thread):
    def __init__(self, q, ocr):
        threading.Thread.__init__(self)
        self.queue = q
        self.ocr = ocr

        self.quit = False

    def run(self):
        while not self.quit:
            try:
                # Process the page
                page = self.queue.get()
                boxing = self.ocr.analyze(page.path)
                page.text = djvubind.ocr.translate(boxing)
            except queue.Empty:
                self.quit = True
            except:
                msg = 'wrn: OCR failure on {0} - This page will have no OCR content.'.format(os.path.split(page.path)[1])
                msg = djvubind.utils.color(msg, 'red')
                print(msg, file=sys.stderr)
            finally:
                self.queue.task_done()


class Project:
    """
    Abstraction of the entire project.  This should make things like status
    reports, clean exits on errors, and access to information a little easier.
    """

    def __init__(self, opts):
        self.get_config(opts)

        self.out = os.path.abspath('book.djvu')

        self.book = djvubind.organizer.Book()
        self.enc = djvubind.encode.Encoder(self.opts)
        #self.ocr = djvubind.ocr.OCR(self.opts)
        if self.opts['ocr']:
            self.ocr = djvubind.ocr.engine(self.opts['ocr_engine'], self.opts['tesseract_options'])
        self.ocr.preserve_ocr = self.opts['preserve_ocr']

    def add_file(self, filename, type='page'):
        """
        Adds a file to the project.
        type can be 'page', 'cover_front', 'cover_back', 'metadata', or 'bookmarks'.
        """

        # Check that type is valid and file exists.
        if type not in ['page', 'cover_front', 'cover_back', 'metadata', 'bookmarks']:
            msg = 'err: Project.add_file(): type "{0}" is unknown.'.format(type)
            print(msg, file=sys.stderr)
            sys.exit(1)
        if not os.path.isfile(filename):
            msg = 'err: Project.add_file(): "{0}" does not exist or is not a file.'.format(filename)
            print(msg, file=sys.stderr)
            sys.exit(1)

        # Hand the files over to self.book to manage.
        if type == 'page':
            self.book.insert_page(filename)
        else:
            self.book.suppliments[type] = filename

        return None

    def analyze(self):
        """
        Retrieve and store information about each image (dpi, bitonal, etc.).
        """

        pagecount = len(self.book.pages)
        threadcount = self.opts['cores']

        if threadcount > pagecount:
            threadcount = pagecount

        # Create queu and populate with pages to process
        q = queue.Queue()
        for i in self.book.pages:
            q.put(i)

        # Create threads to process the pages in queue
        print('  Spawning {0} processing threads.'.format(threadcount))
        for i in range(threadcount):
            p = ThreadAnalyze(q)
            p.daemon = True
            p.start()

        # Wait for everything to digest.  Note that we don't simply call q.join()
        # because it blocks, preventing something like ctrl-c from killing the program.
        while not q.empty():
            try:
                time.sleep(3)
                # Report completion percentage.
                # N.b., this is perfect, since queue.qsize() isn't completely reliable in a threaded
                # environment, but it will do well enough to give the user and idea of where we are.
                position = ( (pagecount - q.qsize() - self.opts['cores']) / pagecount ) * 100
                print('  {0:.2f}% completed.       '.format(position), end='\r')
            except KeyboardInterrupt:
                print('')
                sys.exit(1)
        q.join()

        return None

    def bind(self):
        """
        Fully encodes all images into a single djvu file.  This includes adding
        known ocr information, covers, metadata, etc.
        """

        self.enc.enc_book(self.book, self.out)

        return None

    def get_config(self, opts):
        """
        Retrives configuration options set in the user's config file.  Options
        passed through the command line (already in 'opts') should be
        translated and overwrite config file options.
        """

        # Set default options
        self.opts = {'cores': -1,
                     'ocr': True,
                     'ocr_engine': 'tesseract',
                     'cuneiform_options': '',
                     'tesseract_options': '',
                     'bitonal_encoder': 'cjb2',
                     'color_encoder': 'csepdjvu',
                     'c44_options': '',
                     'cjb2_options': '-lossless',
                     'cpaldjvu_options': '',
                     'csepdjvu_options': '',
                     'minidjvu_options': '--lossy -pages-per-dict 100',
                     'first_main': False,
                     'main_start_number': 1,
                     'frontmatter_page': {},
                     'frontmatter_uppercase': False,
                     'preserve_ocr': False,
                     'win_path': 'C:\\Program Files\\DjVuZone\\DjVuLibre\\'}

        # Load the global config file first
        if not sys.platform.startswith('win'):
            filename = '/etc/djvubind/config'
            if os.path.isfile(filename):
                config_opts = djvubind.utils.parse_config(filename)
                self.opts.update(config_opts)

        # Load the options from the user's config file, if it exists.
        if sys.platform.startswith('win'):
            filename = os.path.expanduser('~\\Application Data\\djvubind\\config')
        else:
            filename = os.path.expanduser('~/.config/djvubind/config')
        filename = os.path.normpath(filename)
        if os.path.isfile(filename):
            config_opts = djvubind.utils.parse_config(filename)
            self.opts.update(config_opts)
        else:
            if os.path.isfile('/etc/djvubind/config'):
                conf_dir = os.path.expanduser('~/.config/djvubind')
                if not os.path.isdir(conf_dir):
                    os.makedirs(conf_dir)
                shutil.copy('/etc/djvubind/config', filename)
                config_opts = djvubind.utils.parse_config(filename)
                self.opts.update(config_opts)
            else:
                msg = 'msg: Project.get_config(): No user config file found ({0}).'.format(filename)
                msg = msg + '\n' + 'A sample config file is included in the source (docs/config).'
                print(msg, file=sys.stderr)


        # Set cetain variables to the proper type
        self.opts['cores'] = int(self.opts['cores'])
        if isinstance(self.opts['ocr'], str):
            self.opts['ocr'] = (self.opts['ocr'] == 'True')

        # Overwrite or create values for certain command line options
        if opts.no_ocr:
            self.opts['ocr'] = False
        if opts.ocr_engine is not None:
            self.opts['ocr_engine'] = opts.ocr_engine
        if opts.tesseract_options is not None:
            self.opts['tesseract_options'] = opts.tesseract_options
        if opts.cuneiform_options is not None:
            self.opts['cuneiform_options'] = opts.cuneiform_options
        if opts.first_main:
            self.opts['first_main'] = opts.first_main
        if opts.main_start_number:
            self.opts['main_start_number'] = opts.main_start_number
        if opts.preserve_ocr:
            self.opts['preserve_ocr'] = opts.preserve_ocr
        for special in opts.frontmatter_page:
            if ':' in special:
                special = special.split(':')
                self.opts['frontmatter_page'][special[0]] = special[1]
            else:
                self.opts['frontmatter_page'][special] = None
        self.opts['frontmatter_uppercase'] = opts.frontmatter_uppercase
        self.opts['verbose'] = opts.verbose
        self.opts['quiet'] = opts.quiet

        # Detect number of cores if not manually set already
        if self.opts['cores'] == -1:
            self.opts['cores'] = djvubind.utils.cpu_count()

        # Update windows PATH so that we can find the executable we need.
        if sys.platform.startswith('win'):
            if self.opts['win_path'] != '':
                os.environ['PATH'] = '{0};{1}'.format(
                    self.opts['win_path'], os.environ['PATH'])

        if self.opts['verbose']:
            print('Executing with these parameters:')
            print(self.opts)
            print('')

        return None

    def get_ocr(self):
        """
        Performs optical character analysis on all images, excluding covers.
        """

        if not self.opts['ocr']:
            print('  OCR is disabled and will be skipped.')
            return None

        pagecount = len(self.book.pages)
        threadcount = self.opts['cores']

        if threadcount > pagecount:
            threadcount = pagecount

        # Create queu and populate with pages to process
        q = queue.Queue()
        for i in self.book.pages:
            q.put(i)

        # Create threads to process the pages in queue
        with tempfile.TemporaryDirectory() as tempdir, \
             djvubind.utils.ChangeDirectory(tempdir):
            origin = os.getcwd()
            os.chdir(tempdir)
            print('  Spawning {0} processing threads.'.format(threadcount))
            for i in range(threadcount):
                p = ThreadOCR(q, self.ocr)
                p.daemon = True
                p.start()

            # Wait for everything to digest.  Note that we don't
            # simply call q.join() because it blocks, preventing
            # something like ctrl-c from killing the program.
            while not q.empty():
                try:
                    time.sleep(3)
                    # Report completion percentage.
                    # N.b., this is not perfect, since queue.qsize()
                    # isn't completely reliable in a threaded
                    # environment, but it will do well enough to give
                    # the user and idea of where we are.
                    position = ( (pagecount - q.qsize() - self.opts['cores']) /
                                 pagecount ) * 100
                    print('  {0:.2f}% completed.       '.format(
                        position), end='\r')
                except KeyboardInterrupt:
                    print('')
                    sys.exit(1)
            q.join()


        return None


if __name__ == '__main__':
    version  = 'djvubind 1.2.1'

    # Command line parsing
    usage = "usage: %prog [options] directory"
    description = """djvubind is designed to facilitate creating high-quality \
djvu files, including positional ocr, metadata, and bookmarks."""
    parser = optparse.OptionParser(
        usage, version=version, description=description)
    parser.set_defaults(
        quiet=False, verbose=False, no_globber=False, no_ocr=False,
        ocr_engine=None, tesseract_options=None, cuneiform_options=None,
        preserve_ocr=False, cover_front='cover_front.jpg',
        cover_back='cover_back.jpg', metadata='meta.dat',
        bookmarks='bm.dat', first_main=False, main_start_number=1,
        frontmatter_page=[], frontmatter_uppercase=False)
    # The default for bookmarks is not “book…” just to make it easier to
    # keep it apart from the output book.djvu
    parser.add_option(
        "--cover-front", dest="cover_front",
        help="""Specifies an alternate front cover image.  By default, \
'%default' is used if present.""")
    parser.add_option(
        "--cover-back", dest="cover_back",
        help="""Specifies an alternate back cover image.  By default, \
'%default' is used if present.""")
    parser.add_option(
        "-m", "--metadata", dest="metadata",
        help="""Specifies an alternate metadata file.  By default, '%default' \
is used if present.""")
    parser.add_option(
        "-b", "--bookmarks", dest="bookmarks",
        help="""Specifies an alternate bookmarks file.  By default, \
'%default' is used if present.""")
    parser.add_option(
        "-n", "--no-globber", action="store_true", dest="no_globber",
        help="Do not overwrite an existing output file.")
    parser.add_option(
        "--no-ocr", action="store_true", dest="no_ocr",
        help="Images will not be processed for text content.")
    parser.add_option(
        "--ocr-engine", dest="ocr_engine",
        help="""Select which ocr engine to use (cuneiform|tesseract). By \
default, '%default' is used.""")
    parser.add_option(
        "--tesseract-options", dest="tesseract_options",
        help="Additional command line options to pass to tesseract.")
    parser.add_option(
        "--cuneiform-options", dest="cuneiform_options",
        help="Additional command line options to pass to cuneiform.")
    parser.add_option(
        "--first-main", dest="first_main",
        help="""Image filename of first page with an arabic number, the \
first page of the main matter. Pages before this will get roman numbers.""")
    parser.add_option(
        "--main-start-number", dest="main_start_number",
        help="""The number for the first page in arabic numerals, \
set if not %default.""")
    parser.add_option(
        "--front-matter-page", action="append", dest="frontmatter_page",
        help="""An image that should be excluded from page numbering. An \
alternate number can be provided after a colon (e.g. page_01.tif:cover).""")
    parser.add_option(
        "--front-matter-uppercase", action="store_true",
        dest="frontmatter_uppercase",
        help="Use uppercase roman numerals instead of lowercase.")
    parser.add_option(
        "--preserve-ocr", action="store_true", dest="preserve_ocr",
        help="""Will not delete ocr files created during processing. Useful \
for manual corrections to ocr.""")
    parser.add_option("-q", "--quiet", action="store_true", dest="quiet")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose")
    (options, args) = parser.parse_args(sys.argv)

    if options.quiet:
        sys.stdout = open(os.devnull, 'w')
    if options.verbose:
        print('djvubind version {0} on {1}'.format(version, sys.platform))

    # Sanity checks on command line arguments and options
    if len(args) == 2:
        if not os.path.isdir(args[1]):
            print('The argument ({0}) is not a directory.'.format(args[1]), file=sys.stderr)
            sys.exit(1)
    elif (len(args) > 2):
        print('Too many arguments, check your command syntax.', file=sys.stderr)
        sys.exit(1)

    # Project needs to be initialized before doing dependency checks, since the
    # configuration file may supply PATH updates for Window environments.
    proj = Project(options)

    # Dependency check
    # N.B. checks for ocr engines *should* take place in ocr.OCR(), since which
    # ones are needed requires knowledge of config preferences, bitonal/nonbitonal, etc.
    # Likewise for encoders other than djvulibre tools (albeit in encode.Encode())
    deps = ['cpaldjvu', 'cjb2', 'djvm', 'djvused', 'identify']
    for dep in deps:
        if (not djvubind.utils.is_executable(dep)):
            print('err: __main__: external dependency ({0}) cannot be found.'.format(dep), file=sys.stderr)
            sys.exit(1)

    if os.path.isfile(proj.out) and options.noglobber:
        print('err: Output file {} exists.'.format(proj.out), file=sys.stderr)
        sys.exit(1)

    # Change to working directory if necessary
    if len(args) == 2:
        os.chdir(args[1])

    # Add files to the project
    print('{0} Collecting files to be processed.'.format(djvubind.utils.color('*', 'green')))
    counter = djvubind.utils.counter(start=1, roman=True)
    if os.path.isfile(options.cover_front):
        options.cover_front = os.path.join(os.getcwd(), options.cover_front)
        proj.add_file(options.cover_front, 'cover_front')
    if os.path.isfile(options.cover_back):
        options.cover_back = os.path.join(os.getcwd(), options.cover_back)
        proj.add_file(options.cover_back, 'cover_back')
    if os.path.isfile(options.metadata):
        options.metadata = os.path.join(os.getcwd(), options.metadata)
        proj.add_file(options.metadata, 'metadata')
    if os.path.isfile(options.bookmarks):
        options.bookmarks = os.path.join(os.getcwd(), options.bookmarks)
        proj.add_file(options.bookmarks, 'bookmarks')
    for filename in djvubind.utils.list_files():
        ext = filename.split('.')[-1]
        ext = ext.lower()
        if (ext in ['tif', 'tiff', 'pnm', 'pbm', 'pgm', 'ppm']) and (
                filename not in [options.cover_front, options.cover_back]):
            proj.add_file(filename, 'page')
            if proj.opts['first_main'] is not False:
                filename = os.path.basename(filename)
                if proj.opts['first_main'] == filename:
                    counter = djvubind.utils.counter(
                        start=int(proj.opts['first_main_number']))
                if filename in proj.opts['frontmatter_page']:
                    proj.book.pages[-1].title = proj.opts['frontmatter_page'][
                        filename]
                else:
                    proj.book.pages[-1].title = next(counter)
                    if proj.opts['frontmatter_uppercase']:
                        proj.book.pages[-1].title = proj.book.pages[
                            -1].title.upper()

    # Check that titles are not being specified without a starting page
    if (proj.opts['first_main'] is False) and (
            proj.opts['frontmatter_page'] != {}):
        msg = 'err: --title-exclude may only be used with --title-start.'
        msg = djvubind.utils.color(msg, 'red')
        print(msg, file=sys.stderr)
        sys.exit(1)

    # Check for duplicate titles
    titles = {}
    for key in proj.book.pages:
        value = key.title
        if value in titles and value is not None:
            titles[value] += 1
        else:
            titles[value] = 1
    dups = [key for key in titles if titles[key]>1]
    if len(dups):
        msg = 'err: The same title cannot be used for multiple pages. This is a limitation of djvused. Duplicated titles are listed below:'
        msg = djvubind.utils.color(msg, 'red')
        print(msg, file=sys.stderr)
        for dup in dups:
            print(dup, file=sys.stderr)
            sys.exit(1)

    if len(proj.book.pages) == 0:
        print('  No files found to bind.')
        sys.exit(0)
    else:
        print('  Binding a total of {0} file(s).'.format(len(proj.book.pages)))

    print('{0} Analyzing image information.'.format(djvubind.utils.color('*', 'green')))
    proj.analyze()
    proj.book.get_dpi()

    print('{0} Performing optical character recognition.'.format(djvubind.utils.color('*', 'green')))
    proj.get_ocr()

    #proj.book.save_report()

    print('{0} Encoding all information to {1}.'.format(djvubind.utils.color('*', 'green'), proj.out))
    proj.bind()
